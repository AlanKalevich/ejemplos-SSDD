<!-- livebook:{"file_entries":[{"name":"elixir-logo.png","type":"attachment"},{"name":"homer-think.jpg","type":"attachment"},{"name":"homer-woo-hoo.png","type":"attachment"},{"name":"homero-preocupado.png","type":"attachment"},{"name":"oh-no.jpeg","type":"attachment"}]} -->

# Elixir 101

## Una introducción rápida a Elixir

![](files/elixir-logo.png)

* Diseñado para desarrollar aplicaciones escalables y tolerantes a fallos.
* Elixir genera bytecode para la máquina virtual de Erlang (BEAM).
* ¿Quien usa Elixir? Discord, Pinterest, Pepsi, Toyota...

<!-- livebook:{"break_markdown":true} -->

Es un lenguaje de programación funcional basado en Erlang/OTP
![](files/oh-no.jpeg)

<!-- livebook:{"break_markdown":true} -->

No existen clases, objetos, instancias... sólo funciones (organizadas en módulos)
![](files/homer-woo-hoo.png)

<!-- livebook:{"break_markdown":true} -->

* Los datos son inmutables (¡hola recursión!)
* Una variable se asocia siempre a un nuevo valor
* No existe el paso por referencia
  ![](files/homero-preocupado.png)

<!-- livebook:{"break_markdown":true} -->

Una función no depende de estado externo:

* procesa sus parámetros y genera una respuesta.
* Predecible y fácilmente testeable.
* Facilita la concurrencia: no hay que “proteger” estados.
  ![](files/homer-think.jpg)

<!-- livebook:{"break_markdown":true} -->

Lo primero que vamos a hacer es crear una _variable_, asignandole un valor e imprimir por la terminal dicho valor.

```elixir
nombre = "Francisco"
IO.puts(nombre)
```

Fantabuloso. `IO.puts` es una función similar a `printf()` en C o `System.out.println()` en Java.

Como Python, Elixir soporta interpolación de cadenas:

```elixir
IO.puts("Hola #{nombre}")
```

¿Qué es el `:ok` que aparece luego la salida de `IO.puts`? Es un átomo, un tipo de dato en Elixir cuyo valor es su propio nombre. En este caso, nos indica el valor de retorno de la función.

<!-- livebook:{"break_markdown":true} -->

Vamos a crear una lista de nombres:

```elixir
estudiantes = ["Heisenberg", "Asimov", "Toriyama"]
```

Supongamos que queremos agregar datos adicionales a cada estudiantes, por ejemplo su edad. Una opción es que cada elemento sea una lista en lugar de un cadena... pero es mejor utilizar un *mapa*.

```elixir
estudiante = %{"nombre" => "Toriyama", "edad" => 42}
IO.puts("Hola, #{estudiante["nombre"]}")
```

Entonces la lista de estudiantes, es una lista de _mapas_:

```elixir
estudiantes = [
  %{:nombre => "Heisenberg", :edad => 42},
  %{:nombre => "Asimov", :edad => 33},
  %{:nombre => "Toriyama", :edad => 38}
]
IO.puts("Hola, #{Enum.at(estudiantes, 0)[:nombre]}")
```

En lugar de cadenas utilizamos _átomos_ para las claves de cada mapa. Esto es una buena práctica, ya que los átomos no se duplican (cada "nombre" utilizado como clave es una cadena diferente).

Es tan común este estilo que Elixir ofrece un atajo sintáctico:

```elixir
estudiantes = [
  %{nombre: "Heisenberg", edad: 42},
  %{nombre: "Asimov", edad: 33},
  %{nombre: "Toriyama", edad: 38}
]
estudiante = Enum.at(estudiantes, 0)
IO.puts("hola, #{estudiante.nombre}")
```

Vamos a hacer una función que imprima el saludo. Notar que la función es anónima, esta asociada a una variable y por eso es necesario el punto luego de su nombre al invocarla:

```elixir
saludar = fn (nombre) ->
  IO.puts("hola, #{nombre}")
end

saludar.(estudiante.nombre)
```

Vamos a ver ahora una funcionalidad importante del lenguaje, el _pattern matching_:

```elixir
[primer_estudiante | el_resto] = estudiantes
saludar.(primer_estudiante.nombre)
el_resto
```

¿Y si solo quisiera el nombre del estudiante?

```elixir
%{nombre: nombre} = estudiante
IO.puts(nombre)
```

No parece muy impresionante. Pero miren esto, obtener el nombre de primer estudiante en la lista (el `_` indica que no me interesa el resto de la lista)

```elixir
[%{nombre: nombre} = primero | _ ] = estudiantes
IO.puts(nombre)
```

Y miren como podemos mejorar nuestra función de saludo:

```elixir
saludar = fn
  %{nombre: nombre} -> IO.puts("hola, #{nombre}")
  _ -> IO.puts("hola, desconocido")
end

saludar.(estudiante)

saludar.([])
```

Ahora, algo de magia :)

```elixir
Enum.each(estudiantes, saludar)
```

¿Y que pasa si quiero definir una función? Tenemos que declararla dentro de un _módulo_:

```elixir
defmodule BuenosModales do

  def saludar (nombre) do
    case nombre do
      %{nombre: nombre} -> IO.puts("hola, #{nombre}")
      _ -> IO.puts "Hola, desconocido" 
    end
  end
  
end

BuenosModales.saludar(estudiante)
```

Eso es todo por ahora...
